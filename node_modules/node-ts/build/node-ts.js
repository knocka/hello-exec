/**
 * @autor Niklas Mollenhauer <holzig@outlook.com>
 * @autor Tim Kluge <timklge@wh2.tu-dresden.de>
 * @license Beerware/Pizzaware
 */
"use strict";
const net = require("net");
const events_1 = require("events");
const util_1 = require("util");
const byline_1 = require("byline");
/**
 * Client that can be used to connect to a TeamSpeak server query API.
 * @todo unit tests
 */
class TeamSpeakClient extends events_1.EventEmitter {
    /**
     * Creates a new instance of TeamSpeakClient for a specific remote host:port.
     * @param {string = TeamSpeakClient.DefaultHost} host Remote host of the TeamSpeak server. Can be an IP address or a host name.
     * @param {number = TeamSpeakClient.DefaultPort} port TCP port of the server query instance of the remote host.
     * @constructor
     */
    constructor(host = TeamSpeakClient.DefaultHost, port = TeamSpeakClient.DefaultPort) {
        super();
        this._queue = null;
        this._host = host;
        this._port = port;
        this._queue = [];
        this._status = -2;
        this.initializeConnection();
    }
    /**
     * Gets the remote host passed to the constructor. Can be an IP address or a host name.
     * @return {string} Remote host of the TeamSpeak server. Can be an IP address or a host name.
     */
    get host() {
        return this._host;
    }
    initializeConnection() {
        this._socket = net.connect(this._port, this._host);
        this._socket.on("error", err => this.emit("error", err));
        this._socket.on("close", () => this.emit("close", this._queue));
        this._socket.on("connect", () => this.onConnect());
    }
    /**
     * Gets called on an opened connection
     */
    onConnect() {
        this._reader = byline_1.createStream(this._socket, { encoding: "utf-8", keepEmptyLines: false });
        this._reader.on("data", line => {
            let s = line.trim();
            // Ignore two first lines sent by server ("TS3" and information message)
            if (this._status < 0) {
                this._status++;
                if (this._status === 0)
                    this.checkQueue();
                return;
            }
            // Server answers with:
            // [- One line containing the answer ]
            // - "error id=XX msg=YY". ID is zero if command was executed successfully.
            if (s.indexOf("error") === 0) {
                const response = this.parseResponse(s.substr("error ".length).trim());
                const res = response.shift();
                const currentError = {
                    id: res["id"] || 0,
                    msg: res["msg"] || ""
                };
                if (currentError.id !== 0)
                    this._executing.error = currentError;
                if (this._executing.rejectFunction && this._executing.resolveFunction) {
                    //item: this._executing || null,
                    const e = this._executing;
                    const data = {
                        cmd: e.cmd,
                        options: e.options || [],
                        text: e.text || null,
                        parameters: e.parameters || {},
                        error: e.error || null,
                        response: e.response || null,
                        rawResponse: e.rawResponse || null
                    };
                    if (data.error && data.error.id !== 0)
                        this._executing.rejectFunction(data);
                    else
                        this._executing.resolveFunction(data);
                }
                this._executing = null;
                this.checkQueue();
            }
            else if (s.indexOf("notify") === 0) {
                s = s.substr("notify".length);
                const response = this.parseResponse(s);
                this.emit(s.substr(0, s.indexOf(" ")), response);
            }
            else if (this._executing) {
                this._executing.rawResponse = s;
                this._executing.response = this.parseResponse(s);
            }
        });
        this.emit("connect");
    }
    send(cmd, params = {}, options = []) {
        if (!cmd)
            return Promise.reject("Empty command");
        let tosend = StringExtensions.tsEscape(cmd);
        for (let v of options)
            tosend += " -" + StringExtensions.tsEscape(v);
        for (let key in params) {
            if (!params.hasOwnProperty(key))
                continue;
            const value = params[key];
            if (!util_1.isArray(value)) {
                tosend += " " + StringExtensions.tsEscape(key.toString()) + "=" + StringExtensions.tsEscape(value.toString());
            }
        }
        // Handle multiple arrays correctly
        // Get all array in the params
        const arrayParamKeys = [];
        for (let key in params) {
            if (params.hasOwnProperty(key) && util_1.isArray(params[key]))
                arrayParamKeys.push(key);
        }
        if (arrayParamKeys.length > 0) {
            let escapedSegments = "";
            const firstArray = params[arrayParamKeys[0]];
            for (let i = 0; i < firstArray.length; ++i) {
                let segment = "";
                for (var key of arrayParamKeys) {
                    segment += StringExtensions.tsEscape(key) + "=" + StringExtensions.tsEscape(params[key][i]) + " ";
                }
                escapedSegments += segment.slice(0, -1) + "|";
            }
            if (escapedSegments.length > 0)
                tosend += " " + escapedSegments.slice(0, -1);
        }
        return new Promise((resolve, reject) => {
            this._queue.push({
                cmd: cmd,
                options: options,
                parameters: params,
                text: tosend,
                resolveFunction: resolve,
                rejectFunction: reject
            });
            if (this._status === 0)
                this.checkQueue();
        });
    }
    /**
     * Parses a query API response.
     */
    parseResponse(s) {
        const records = s.split("|");
        // Test this
        const response = records.map(currentItem => {
            const args = currentItem.split(" ");
            const thisrec = {};
            for (let v of args) {
                if (v.indexOf("=") <= -1) {
                    thisrec[v] = "";
                    continue;
                }
                const key = StringExtensions.tsUnescape(v.substr(0, v.indexOf("=")));
                const value = StringExtensions.tsUnescape(v.substr(v.indexOf("=") + 1));
                thisrec[key] = (parseInt(value, 10).toString() == value) ? parseInt(value, 10) : value;
            }
            return thisrec;
        });
        if (response.length === 0)
            return null;
        return response;
    }
    /**
     * Gets pending commands that are going to be sent to the server. Note that they have been parsed - Access pending[0].text to get the full text representation of the command.
     * @return {QueryCommand[]} Pending commands that are going to be sent to the server.
     */
    get pending() {
        return this._queue.slice(0);
    }
    /**
     * Clears the queue of pending commands so that any command that is currently queued won't be executed.
     * @return {QueryCommand[]} Array of commands that have been removed from the queue.
     */
    clearPending() {
        const q = this._queue;
        this._queue = [];
        return q;
    }
    /**
     * Checks the current command queue and sends them if needed.
     */
    checkQueue() {
        if (!this._executing && this._queue.length >= 1) {
            this._executing = this._queue.shift();
            this._socket.write(this._executing.text + "\n");
        }
    }
    /**
     * Sets the socket to timeout after timeout milliseconds of inactivity on the socket. By default net.Socket do not have a timeout.
     */
    setTimeout(timeout) {
        return this._socket.setTimeout(timeout, () => {
            this._socket.destroy();
            this.emit("timeout");
        });
    }
    unsetTimeout() {
        /*
         * If timeout is 0, then the existing idle timeout is disabled.
         * See: https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback
         */
        return this.setTimeout(0);
    }
}
TeamSpeakClient.DefaultHost = "localhost";
TeamSpeakClient.DefaultPort = 10011;
exports.TeamSpeakClient = TeamSpeakClient;
class StringExtensions {
    /**
     * Escapes a string so it can be safely used for querying the api.
     * @param  {string} s The string to escape.
     * @return {string}   An escaped string.
     */
    static tsEscape(s) {
        let r = String(s);
        r = r.replace(/\\/g, "\\\\"); // Backslash
        r = r.replace(/\//g, "\\/"); // Slash
        r = r.replace(/\|/g, "\\p"); // Pipe
        r = r.replace(/\n/g, "\\n"); // Newline
        r = r.replace(/\r/g, "\\r"); // Carriage Return
        r = r.replace(/\t/g, "\\t"); // Tab
        r = r.replace(/\v/g, "\\v"); // Vertical Tab
        r = r.replace(/\f/g, "\\f"); // Formfeed
        r = r.replace(/ /g, "\\s"); // Whitespace
        return r;
    }
    /**
     * Unescapes a string so it can be used for processing the response of the api.
     * @param  {string} s The string to unescape.
     * @return {string}   An unescaped string.
     */
    static tsUnescape(s) {
        let r = String(s);
        r = r.replace(/\\s/g, " "); // Whitespace
        r = r.replace(/\\p/g, "|"); // Pipe
        r = r.replace(/\\n/g, "\n"); // Newline
        r = r.replace(/\\f/g, "\f"); // Formfeed
        r = r.replace(/\\r/g, "\r"); // Carriage Return
        r = r.replace(/\\t/g, "\t"); // Tab
        r = r.replace(/\\v/g, "\v"); // Vertical Tab
        r = r.replace(/\\\//g, "\/"); // Slash
        r = r.replace(/\\\\/g, "\\"); // Backslash
        return r;
    }
}
/*

    Enums imported from documentation.

*/
(function (YesNo) {
    YesNo[YesNo["No"] = 0] = "No";
    YesNo[YesNo["Yes"] = 1] = "Yes";
})(exports.YesNo || (exports.YesNo = {}));
var YesNo = exports.YesNo;
(function (HostMessageMode) {
    /**
     * 1: display message in chatlog
     */
    HostMessageMode[HostMessageMode["HostMessageMode_LOG"] = 1] = "HostMessageMode_LOG";
    /**
     * 2: display message in modal dialog
     */
    HostMessageMode[HostMessageMode["HostMessageMode_MODAL"] = 2] = "HostMessageMode_MODAL";
    /**
     * 3: display message in modal dialog and close connection
     */
    HostMessageMode[HostMessageMode["HostMessageMode_MODALQUIT"] = 3] = "HostMessageMode_MODALQUIT";
})(exports.HostMessageMode || (exports.HostMessageMode = {}));
var HostMessageMode = exports.HostMessageMode;
(function (HostBannerMode) {
    /**
     * 0: do not adjust
     */
    HostBannerMode[HostBannerMode["HostMessageMode_NOADJUST"] = 0] = "HostMessageMode_NOADJUST";
    /**
     * 1: adjust but ignore aspect ratio (like TeamSpeak 2)
     */
    HostBannerMode[HostBannerMode["HostMessageMode_IGNOREASPECT"] = 1] = "HostMessageMode_IGNOREASPECT";
    /**
     * 2: adjust and keep aspect ratio
     */
    HostBannerMode[HostBannerMode["HostMessageMode_KEEPASPECT"] = 2] = "HostMessageMode_KEEPASPECT";
})(exports.HostBannerMode || (exports.HostBannerMode = {}));
var HostBannerMode = exports.HostBannerMode;
(function (Codec) {
    /**
     * 0: speex narrowband (mono, 16bit, 8kHz)
     */
    Codec[Codec["CODEC_SPEEX_NARROWBAND"] = 0] = "CODEC_SPEEX_NARROWBAND";
    /**
     * 1: speex wideband (mono, 16bit, 16kHz)
     */
    Codec[Codec["CODEC_SPEEX_WIDEBAND"] = 1] = "CODEC_SPEEX_WIDEBAND";
    /**
     * 2: speex ultra-wideband (mono, 16bit, 32kHz)
     */
    Codec[Codec["CODEC_SPEEX_ULTRAWIDEBAND"] = 2] = "CODEC_SPEEX_ULTRAWIDEBAND";
    /**
     * 3: celt mono (mono, 16bit, 48kHz)
     */
    Codec[Codec["CODEC_CELT_MONO"] = 3] = "CODEC_CELT_MONO";
})(exports.Codec || (exports.Codec = {}));
var Codec = exports.Codec;
(function (CodecEncryptionMode) {
    /**
     * 0: configure per channel
     */
    CodecEncryptionMode[CodecEncryptionMode["CODEC_CRYPT_INDIVIDUAL"] = 0] = "CODEC_CRYPT_INDIVIDUAL";
    /**
     * 1: globally disabled
     */
    CodecEncryptionMode[CodecEncryptionMode["CODEC_CRYPT_DISABLED"] = 1] = "CODEC_CRYPT_DISABLED";
    /**
     * 2: globally enabled
     */
    CodecEncryptionMode[CodecEncryptionMode["CODEC_CRYPT_ENABLED"] = 2] = "CODEC_CRYPT_ENABLED";
})(exports.CodecEncryptionMode || (exports.CodecEncryptionMode = {}));
var CodecEncryptionMode = exports.CodecEncryptionMode;
(function (TextMessageTargetMode) {
    /**
     * 1: target is a client
     */
    TextMessageTargetMode[TextMessageTargetMode["TextMessageTarget_CLIENT"] = 1] = "TextMessageTarget_CLIENT";
    /**
     * 2: target is a channel
     */
    TextMessageTargetMode[TextMessageTargetMode["TextMessageTarget_CHANNEL"] = 2] = "TextMessageTarget_CHANNEL";
    /**
     * 3: target is a virtual server
     */
    TextMessageTargetMode[TextMessageTargetMode["TextMessageTarget_SERVER"] = 3] = "TextMessageTarget_SERVER";
})(exports.TextMessageTargetMode || (exports.TextMessageTargetMode = {}));
var TextMessageTargetMode = exports.TextMessageTargetMode;
(function (LogLevel) {
    /**
     * 1: everything that is really bad
     */
    LogLevel[LogLevel["LogLevel_ERROR"] = 1] = "LogLevel_ERROR";
    /**
     * 2: everything that might be bad
     */
    LogLevel[LogLevel["LogLevel_WARNING"] = 2] = "LogLevel_WARNING";
    /**
     * 3: output that might help find a problem
     */
    LogLevel[LogLevel["LogLevel_DEBUG"] = 3] = "LogLevel_DEBUG";
    /**
     * 4: informational output
     */
    LogLevel[LogLevel["LogLevel_INFO"] = 4] = "LogLevel_INFO";
})(exports.LogLevel || (exports.LogLevel = {}));
var LogLevel = exports.LogLevel;
(function (ReasonIdentifier) {
    /**
     * 4: kick client from channel
     */
    ReasonIdentifier[ReasonIdentifier["REASON_KICK_CHANNEL"] = 4] = "REASON_KICK_CHANNEL";
    /**
     * 5: kick client from server
     */
    ReasonIdentifier[ReasonIdentifier["REASON_KICK_SERVER"] = 5] = "REASON_KICK_SERVER";
})(exports.ReasonIdentifier || (exports.ReasonIdentifier = {}));
var ReasonIdentifier = exports.ReasonIdentifier;
(function (PermissionGroupDatabaseTypes) {
    /**
     * 0: template group (used for new virtual servers)
     */
    PermissionGroupDatabaseTypes[PermissionGroupDatabaseTypes["PermGroupDBTypeTemplate"] = 0] = "PermGroupDBTypeTemplate";
    /**
     * 1: regular group (used for regular clients)
     */
    PermissionGroupDatabaseTypes[PermissionGroupDatabaseTypes["PermGroupDBTypeRegular"] = 1] = "PermGroupDBTypeRegular";
    /**
     * 2: global query group (used for ServerQuery clients)
     */
    PermissionGroupDatabaseTypes[PermissionGroupDatabaseTypes["PermGroupDBTypeQuery"] = 2] = "PermGroupDBTypeQuery";
})(exports.PermissionGroupDatabaseTypes || (exports.PermissionGroupDatabaseTypes = {}));
var PermissionGroupDatabaseTypes = exports.PermissionGroupDatabaseTypes;
(function (PermissionGroupTypes) {
    /**
     * 0: server group permission
     */
    PermissionGroupTypes[PermissionGroupTypes["PermGroupTypeServerGroup"] = 0] = "PermGroupTypeServerGroup";
    /**
     * 1: client specific permission
     */
    PermissionGroupTypes[PermissionGroupTypes["PermGroupTypeGlobalClient"] = 1] = "PermGroupTypeGlobalClient";
    /**
     * 2: channel specific permission
     */
    PermissionGroupTypes[PermissionGroupTypes["PermGroupTypeChannel"] = 2] = "PermGroupTypeChannel";
    /**
     * 3: channel group permission
     */
    PermissionGroupTypes[PermissionGroupTypes["PermGroupTypeChannelGroup"] = 3] = "PermGroupTypeChannelGroup";
    /**
     * 4: channel-client specific permission
     */
    PermissionGroupTypes[PermissionGroupTypes["PermGroupTypeChannelClient"] = 4] = "PermGroupTypeChannelClient";
})(exports.PermissionGroupTypes || (exports.PermissionGroupTypes = {}));
var PermissionGroupTypes = exports.PermissionGroupTypes;
(function (TokenType) {
    /**
     * 0: server group token (id1={groupID} id2=0)
     */
    TokenType[TokenType["TokenServerGroup"] = 0] = "TokenServerGroup";
    /**
     * 1: channel group token (id1={groupID} id2={channelID})
     */
    TokenType[TokenType["TokenChannelGroup"] = 1] = "TokenChannelGroup";
})(exports.TokenType || (exports.TokenType = {}));
var TokenType = exports.TokenType;
